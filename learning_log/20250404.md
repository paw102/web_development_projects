# 금일 수업 계획
## 환경 변수를 적용한 리팩토링
서버 URL 은 더 많은 CRUD 기능을 만들 때 소스 코드에서 여러 번 반복될 수 있으며 백엔드가 localhost 가 아닌 다른 서버에 배포될 때 변경될 수 있기 때문에 환경 변수로 정의하는 편이 안전함
그럴 경우 URL 이 바뀌더라도 한 번만 수정하면 되기 떄문 -> 즉, 하드코딩을 최대한 줄일 것

Vite 프로젝트를 사용한다면, 환경 변수 이름은
VITE_ 로 시작해야 합니다. 접두사가 VITE_ 인 변수만 소스 코드에서 접근이 가능합니다.

car-front (가장 상단)에 우클릭 -> new file -> .env

```java
VITE_API_URL = http://localhost:8080
```

여기저기 흩어져있는 API 호출 함수들을 자체 모듈로 분리
src -> 우클릭 -> new folder -> api -> carapi.ts

Carlist.tsx 파일 내부에서 getCars 함수를 분리해올겁니다. 그리고 다른 컴포넌트에서도 이용할 수 있도록 export 도 추가할겁니다.
비트에서 환경변수는 import.meta.env 를 통해 앱 소스코드에 문자열로 접근이 가능합니다. 그런 다음에 서버 URL 을 통해 getCars 함수로 가져와서 이용 가능합니다.
전역적으로 사용할 예정이니 axios 와 CarResponse 타입도 carapi.ts 로 임포트 할 필요성이 있음.

## 페이징, 필터링, 정렬 추가 (가능하다면)
* 혹시 버전 실수할까봐 미리 명시합니다. 오늘 수업 때 사용할 예정입니다.
기존 버전 삭제
npm uninstall @mui/material @mui/x-data-grid

MUI 5.17 버전 설치 
npm install @mui/material@5.17.1 @emotion/react@11.14.0 @emotion/styled@11.14.0

data-grid 재설치 
npm install @mui/x-data-grid@6.20.4


```tsx
import { useQuery } from "@tanstack/react-query";
import { CarResponse } from "../types";
import { getCars } from "../api/carapi";
import { DataGrid, GridColDef } from "@mui/x-data-grid";

function Carlist() {
  const { data, error, isSuccess} = useQuery({
    queryKey: ["cars"],
    queryFn: getCars
  });

  const columns: GridColDef[] = [
    {field: 'brand', headerName: 'Brand', width: 200},
    {field: 'model', headerName: 'Model', width: 200},
    {field: 'color', headerName: 'Color', width: 200},
    {field: 'registrationNumber', headerName: 'Reg.nr', width: 150},
    {field: 'modelYear', headerName: 'Model Year', width: 150},
    {field: 'price', headerName: 'Price', width: 150},
  ]

  if(!isSuccess) {
    return <span>Loading...</span>
  }
  else if (error) {
    return <span>자동차 데이터 가져오기 중 오류 발생 😢</span>
  }
  else {
    return(
      <table>
        <tbody>
          {
            data.map((car: CarResponse)=> 
            <tr key={car._links.self.href}>
              <td>{car.brand}</td>
              <td>{car.model}</td>
              <td>{car.color}</td>
              <td>{car.registrationNumber}</td>
              <td>{car.modelYear}</td>
              <td>{car.price}</td>
            </tr>)
          }
        </tbody>
      </table>
    );
  }
}

export default Carlist;
```
GridColDef 정의 후에는 
기존 return 내에서의 table 을 삭제 해야하므로 남겨놨습니다.

```tsx
return(
  <DataGrid
    rows={data}
    columns={columns}
    getRowId={row => row._links.self.href}
  />
);
```
DataGrid 의 내부에 {rows, columns, getRowId} -> props drilling

## 삭제 기능을 구현

getRowId={row => row._links.self.href} 를 고려하였을 때,
http://localhost:8080/api/cars/{id} 로 DELETE 요청을 날렸을 때,
데이터베이스에서 해당 id의 정보를 삭제하는 것이 가능합니다.

MUI DataGrid 에서 각 row 에 대한 버튼을 생성


```tsx
  const columns: GridColDef[] = [
    {field: 'brand', headerName: 'Brand', width: 200},
    {field: 'model', headerName: 'Model', width: 200},
    {field: 'color', headerName: 'Color', width: 200},
    {field: 'registrationNumber', headerName: 'Reg.nr', width: 150},
    {field: 'modelYear', headerName: 'Model Year', width: 150},
    {field: 'price', headerName: 'Price', width: 150},
    {
      field: 'edit',
      headerName: '',
      width: 90,
      sortable: false,
      filterable: false,
      disableColumnMenu: true,
      renderCell: (params: GridCellParams) =>
        <button
          onClick={() => alert(params.row._links.car.href)}
        >
          삭제
        </button>
    }
  ]
```
삭제 버튼을 구현했고, react 형태로 내부에 callback 를 넣어서, 구현했습니다.
중요한 점이 columns에 column 을 하나 더 추가할 때 객체의 형태로 했구요,
이전에는 다 true 인 sortable / filterable 을 false 로 수동으로 잡아줬다는 점,
그리고

renderCell 개념입니다.

renderCell - 컬럼 속성에서 컨텐츠가 렌더링 되는 방식을 정의함.
이상에서 함수에 전달되는 params argument 는 row 의 모든 값을 포함하는 row 객체에 해당하기 때문에 id 값만 추출하기 위해서 row._links.car.href 로 가지고 왔다는 점을 확인할 수 있습니다.

그래서 현재 코드 방식으로 alert을 통해서 id 값을 이용자가 확인 할 수 있도록 코드를 작성했다고 볼 수 있겠습니다.

이제 id 를 확인할 수 있기 때문에 그 아이디를 가지고 DELETE 요청을 보낼 수 있게끔 작성해야 할 겁니다.

Axios delete 메서드를 이용하여 DELETE 요청을 자동차 링크에 전송할 수 있도록 하는 deleteCar 함수를 구현할겁니다.

-> carapi.ts 에 할겁니다. -> export 도 있겠죠

```ts
//carapi.ts
export const deleteCar = async (link: string): Promise<CarResponse> => {
  const response = await axios.delete(link);
  return response.data
}
```
삭제 처리가 Carlist 컴포넌트에서 일어나야 합니다. useMutation 훅을 사용할 예정

```tsx
import { useQuery, useMutation } from "@tanstack/react-query";
import { getCars, deleteCar } from "../api/carapi";
import { DataGrid, GridCellParams, GridColDef } from "@mui/x-data-grid";

function Carlist() {
  const { data, error, isSuccess} = useQuery({
    queryKey: ["cars"],
    queryFn: getCars
  });

  const { mutate } = useMutation(deleteCar, {
    onSuccess : () => {
      // 자동차 삭제가 되고 난 이후에 실행되는 로직
    },
    onError : (err) => {
      console.log(err);
    },
  });

  const columns: GridColDef[] = [
    {field: 'brand', headerName: 'Brand', width: 200},
    {field: 'model', headerName: 'Model', width: 200},
    {field: 'color', headerName: 'Color', width: 200},
    {field: 'registrationNumber', headerName: 'Reg.nr', width: 150},
    {field: 'modelYear', headerName: 'Model Year', width: 150},
    {field: 'price', headerName: 'Price', width: 150},
    {
      field: 'edit',
      headerName: '',
      width: 90,
      sortable: false,
      filterable: false,
      disableColumnMenu: true,
      renderCell: (params: GridCellParams) =>
        <button
          onClick={() => mutate(params.row._links.car.href)}
        >
          삭제
        </button>
    }
  ]
```

이상까지 작성한 상황에서 앱에서 삭제 버튼을 누르게 되면 -> 푸른색으로 활성화는 되지만 변화가 없었습니다 (사실 아무데나 눌러도 푸른색으로 활성화됩니다.)

그리고 새로고침을 하게 되면 삭제 버튼을 누른 자동차 데이터가 사라진 점을 확인할 수 있습니다.

axios.delete 메서드가 성공적으로 작동했음을 알 수 있습니다.
onSuccess 이후의 로직을 작성하지 않았기 때문에 프론트앤드에서는 멈춰있는 상태라고 할 수 있습니다.

그리면 우리가 다음번에 해야할 일은 뭐다?

자동차가 삭제되면 다시 DB를 읽어와서 최신화된 DB를 보여줄 필요가 있겠다.

react query 에서 가져온 데이터는 쿼리 클라이언트가 처리하는 캐시에 저장되고, 쿼리 클라이언트에는 데이터를 '다시' 가져오는 데 이용 할 수 있는 쿼리무효화 기능이 있습니다.

먼저, 쿼리 클라이언트를 반환하는 useQueryClient 훅 함수를 가져올 예정
(queryClient 랑 다릅니다!!!!!)

```tsx
const queryClient = useQueryClient();

const { mutate } = useMutation(deleteCar, {
  onSuccess : () => {
    queryClient.invalidateQueries({queryKey: ['cars']});
  },
  onError : (err) => {
    console.log(err);
  },
});
```
이상의 코드에서 쿼리 클라이언트에는 삭제에 성공한 후에 데이터를 다시 가져오기 위해 호출할 수 있는 invalidateQueries 메서드가 있고, 이를 통해 다시 가져오려는 쿼리의 키를 전달할 수 있습니다.

```tsx
  return(
    <DataGrid
      rows={data}
      columns={columns}
      getRowId={row => row._links.self.href}
      // disableRowSelectionOnClick = {true}
    />
  );
```
disableRowSelectionOnClick = {true}
이렇게 쓰면 데이터 한 줄 선택하는거 활성활르 무효화시킬 수 있겠습니다
이건 뭐 중요한건 아니고, 그냥 그런 기능도 있다 정도로 보시면 됩니다.

## 메시지 표시기능 구현
삭제에 성공했거나 오류가 있는 경우 사용자에게 피드백을 할 예정 (현재는 삭제되면 그냥 날라가고, 오류가 발생했을 경우에는 console.log(err)을 통해서 개발자도구에서만 오류가 났음을 확인 할 수 있습니다.)

삭제 상태를 표시하도록 할 MUI SnackBar 컴포넌트를 사용할 예정
snackBar - open 프롭값은 bool 타입이고, 이 값이 true 라면 컴포넌트가 표시되고, false 라면 숨겨집니다.

useState에 bool 값을 넣어서, SnackBar open 에다가 그 useState 값을 대입해서 true 가 되면 메시지를 띄울 수 있도록 작성할 예정입니다.

기본적으로 삭제 후에만 메시지가 표시되어야하기 때문에 초기값은 false 로 잡을 필요가 있겠습니다.

Toast Message 개념
- 화면 상에 일시적으로 나타났다가 사라지는 알람 메시지를 의미함
- 사용자 액션에 대한 간단한 피드백을 주기 위해 사용되는 비모달 (Non-modal)

SnackBar 컴포넌트는 이상의 Toast Message 를 구현하기 위해 자주 사용되는 MUI 컴포넌트입니다.